using AdventOfCode.Common;
using AdventOfCode.Core;
using System.Collections.Generic;
using System.ComponentModel;
namespace AdventOfCode.Y2024 {
    [Description("Monkey Market")]
    public class Puzzle22 : ASolver {
        private List<int> secrets = new();
        private bool[] sets = new bool[1 << 20];
        private int[] totals = new int[1 << 20];

        public override void Setup() {
            foreach (string line in Input.Split('\n')) {
                secrets.Add(line.ToInt());
            }
        }

        [Description("What is the sum of the 2000th secret number generated by each buyer?")]
        public override string SolvePart1() {
            static int Generate(int number) {
                number = (number ^ (number << 6)) & 0xffffff;
                number = (number ^ (number >> 5)) & 0xffffff;
                return (number ^ (number << 11)) & 0xffffff;
            }

            List<int> seen = new();
            long total = 0;
            for (int i = 0; i < secrets.Count; i++) {
                int secret = secrets[i];
                int sequence = 0;
                for (int j = 0; j < 2000; j++) {
                    int newSecret = Generate(secret);
                    int price = newSecret % 10;
                    sequence = ((sequence << 5) | (price - (secret % 10) + 9)) & 0xfffff;
                    secret = newSecret;
                    if (j >= 3 && !sets[sequence]) {
                        seen.Add(sequence);
                        sets[sequence] = true;
                        totals[sequence] += price;
                    }
                }

                for (int j = 0; j < seen.Count; j++) {
                    sets[seen[j]] = false;
                }
                seen.Clear();

                total += secret;
            }
            return $"{total}";
        }

        [Description("What is the most bananas you can get?")]
        public override string SolvePart2() {
            int best = 0;
            for (int i = 0; i < totals.Length; i++) {
                if (totals[i] > best) {
                    best = totals[i];
                }
            }
            return $"{best}";
        }
    }
}